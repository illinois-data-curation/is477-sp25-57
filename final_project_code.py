# -*- coding: utf-8 -*-
"""Final Project Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lDi2raU2edyx3dBMMFENislZhO-w29Ad
"""

import requests
import requests

variables_url = "https://api.census.gov/data/2023/acs/acs5/subject/variables.json"

response = requests.get(variables_url)
variables = response.json()

for key in list(variables['variables'].keys())[:10]:
    print(key, "-", variables['variables'][key]['label'])

import pandas as pd

base_url = "https://api.census.gov/data/2023/acs/acs5/subject"


variables = [
    "NAME",  # Geographic name

    # Housing Costs
    "S2504_C01_001E",  # Median selected monthly owner costs (dollars)
    "S2504_C01_002E",  # Median selected monthly owner costs as % of income
    "S2504_C01_003E",  # Median gross rent (dollars)
    "S2504_C01_004E",  # Median gross rent as % of income

    # Housing Characteristics
    "S2502_C01_001E",  # Total housing units
    "S2502_C01_002E",  # Occupied housing units
    "S2502_C01_003E",  # Vacant housing units
    "S2502_C01_004E",  # Homeowner vacancy rate
    "S2502_C01_005E",  # Rental vacancy rate

    # Financial Factors
    "S1901_C01_012E",  # Median household income (dollars)
    "S2503_C01_001E",  # Median value of owner-occupied housing units
    "S2507_C01_001E",  # Median gross rent as % of household income

    # Household Composition
    "S1101_C01_001E",  # Total households
    "S1101_C01_002E",  # Family households
    "S1101_C01_003E",  # Non-family households

    # Additional Factors
    "S2506_C01_001E",  # Average household size of owner-occupied unit
    "S2506_C01_002E",  # Average household size of renter-occupied unit
    "S2501_C01_001E",   # Total housing units by type

    #Demographics
    "S0101_C01_001E",  # Total population
    "S0101_C01_026E",  # Median age
    "S1101_C01_005E",  # Married-couple families
    "S1101_C01_006E",  # Single father households
    "S1101_C01_007E",  # Single mother households
    "S1701_C01_042E",  # Poverty rate

]

# Define parameters
# params = {
#     "get":
#     "for": "state:*",  # Get data for all states
#     "key": "4b77c0db5740bad31481934237ac76f39a434232"  # Your API key
# }



params = {
    "get": ",".join(variables),
    "for": "county:*",
    "in": "state:*", #Get data for all states
    "key": "4b77c0db5740bad31481934237ac76f39a434232"  
}


response = requests.get(base_url, params=params)
data = response.json()

acs_df = pd.DataFrame(data[1:], columns=data[0])



import pandas as pd


column_rename = {
    # Housing Costs
    "S2504_C01_001E": "median_owner_costs",
    "S2504_C01_002E": "owner_costs_pct_income",
    "S2504_C01_003E": "median_rent",
    "S2504_C01_004E": "rent_pct_income",

    # Housing Characteristics
    "S2502_C01_001E": "total_housing_units",
    "S2502_C01_002E": "occupied_housing_units",
    "S2502_C01_003E": "vacant_housing_units",
    "S2502_C01_004E": "homeowner_vacancy_rate",
    "S2502_C01_005E": "rental_vacancy_rate",

    # Financial
    "S1901_C01_012E": "median_income",
    "S2503_C01_001E": "median_home_value",
    "S2507_C01_001E": "rent_pct_household_income",

    # Household
    "S1101_C01_001E": "total_households",
    "S1101_C01_002E": "family_households",
    "S1101_C01_003E": "nonfamily_households",

    # Household Size
    "S2506_C01_001E": "avg_household_size_owners",
    "S2506_C01_002E": "avg_household_size_renters",
    "S2501_C01_001E": "total_housing_units_by_type",

    # Demographics (confirmed working ones)
    "S0101_C01_001E": "total_population",
    "S0101_C01_026E": "median_age",
    "S1101_C01_005E": "married_couple_families",
    "S1101_C01_006E": "single_father_households",
    "S1101_C01_007E": "single_mother_households",
    "S1701_C01_042E": "poverty_rate_pct"
}

acs_df = acs_df.rename(columns={k: v for k, v in column_rename.items() if k in acs_df.columns})

print("Renamed columns:")
print(acs_df.columns.tolist())
acs_df
acs_df['CountyFIPS'] = acs_df['state'] + acs_df['county']
acs_df['FullFIPS'] = acs_df['CountyFIPS']
acs_df

import pandas as pd
kaggle_df = pd.read_csv("House_price_multifeatures.csv")
kaggle_df.columns

kaggle_df.columns

import pandas as pd

# Dictionary to normalize state names/typos to standard abbreviations
state_normalization = {
    'FLORIDA': 'FL', 'CALIFORNIA': 'CA', 'TEXAS': 'TX', 'OHIO': 'OH',
    'NEW YORK': 'NY', 'NEW JERSEY': 'NJ', 'VIRGINIA': 'VA', 'GEORGIA': 'GA',
    'MICHIGAN': 'MI', 'ILLINOIS': 'IL', 'MISSOURI': 'MO', 'PENNSYLVANIA': 'PA',
    'ALABAMA': 'AL', 'NORTH CAROLINA': 'NC', 'SOUTH CAROLINA': 'SC',
    'COLORADO': 'CO', 'CONNECTICUT': 'CT', 'DELAWARE': 'DE', 'HAWAII': 'HI',
    'IDAHO': 'ID', 'INDIANA': 'IN', 'IOWA': 'IA', 'KENTUCKY': 'KY',
    'LOUISIANA': 'LA', 'MAINE': 'ME', 'MARYLAND': 'MD', 'MASSACHUSETTS': 'MA',
    'MINNESOTA': 'MN', 'MISSISSIPPI': 'MS', 'NEBRASKA': 'NE', 'NEVADA': 'NV',
    'NEW HAMPSHIRE': 'NH', 'NEW MEXICO': 'NM', 'NORTH DAKOTA': 'ND',
    'OKLAHOMA': 'OK', 'OREGON': 'OR', 'RHODE ISLAND': 'RI', 'TENNESSEE': 'TN',
    'UTAH': 'UT', 'VERMONT': 'VT', 'WASHINGTON': 'WA', 'WEST VIRGINIA': 'WV',
    'WISCONSIN': 'WI', 'WYOMING': 'WY', 'DISTRICT OF COLUMBIA': 'DC',

    'PENNSLYVANIA': 'PA', ' VIRGINIA': 'VA', ' CALIFORNIA': 'CA',
    ' FL': 'FL', ' NJ': 'NJ', ' CA': 'CA', ' UNITED STATES OF AMERICA': 'US',
    'ENGLAND U K': 'UK', 'GREAT BRITAIN & NRTHRN IR': 'UK',

    'PUERTO RICO': 'PR', 'GUAM': 'GU', 'VIRGIN ISLANDS': 'VI'
}

kaggle_df['State'] = (
    kaggle_df['OwnerState']
    .str.upper()                
    .str.strip()                
    .replace(state_normalization)  
)


kaggle_df['State'] = kaggle_df['State'].str[:2]

valid_us_states = {
    'AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA',
    'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD',
    'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ',
    'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC',
    'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY',
    'DC'  # Washington, D.C.
}

kaggle_df['IsValidState'] = kaggle_df['State'].isin(valid_us_states)


state_to_fips = {
    'AL': '01', 'AK': '02', 'AZ': '04', 'AR': '05', 'CA': '06',
    'CO': '08', 'CT': '09', 'DE': '10', 'FL': '12', 'GA': '13',
    'HI': '15', 'ID': '16', 'IL': '17', 'IN': '18', 'IA': '19',
    'KS': '20', 'KY': '21', 'LA': '22', 'ME': '23', 'MD': '24',
    'MA': '25', 'MI': '26', 'MN': '27', 'MS': '28', 'MO': '29',
    'MT': '30', 'NE': '31', 'NV': '32', 'NH': '33', 'NJ': '34',
    'NM': '35', 'NY': '36', 'NC': '37', 'ND': '38', 'OH': '39',
    'OK': '40', 'OR': '41', 'PA': '42', 'RI': '44', 'SC': '45',
    'SD': '46', 'TN': '47', 'TX': '48', 'UT': '49', 'VT': '50',
    'VA': '51', 'WA': '53', 'WV': '54', 'WI': '55', 'WY': '56',
    'DC': '11'
}


kaggle_df['CountyFIPS'] = (
    kaggle_df['CountyFIPS']
    .fillna(0)          
    .astype(int)        
    .astype(str)        
    .str.zfill(3)       
    .replace('000', pd.NA)  
)

kaggle_df['StateFIPS'] = kaggle_df['State'].map(state_to_fips)
kaggle_df['FullFIPS'] = kaggle_df['StateFIPS'] + kaggle_df['CountyFIPS']

print("Cleaned State Codes:", kaggle_df['State'].unique())
print("Invalid States:", kaggle_df[~kaggle_df['IsValidState']]['OwnerState'].unique())
print("\nCountyFIPS sample:")

kaggle_df['FullFIPS']
kaggle_df.dtypes

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
from sklearn.linear_model import LassoCV
import statsmodels.api as sm
import statsmodels.formula.api as smf
# from mgwr.sel_bw import Sel_BW
# from mgwr.gwr import GWR
import shap

# Merge datasets
merged_df = pd.merge(
    acs_df,
    kaggle_df,
    on='FullFIPS',
    how='inner',
    suffixes=('_acs', '_kaggle')
)
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
from sklearn.linear_model import LassoCV
import statsmodels.api as sm
import statsmodels.formula.api as smf
import shap

# Ensure numeric types for key columns
numeric_cols = [
    'median_home_value', 'median_income', 'poverty_rate_pct',
    'rent_pct_income', 'avg_household_size_owners'
]

for col in numeric_cols:
    if col in merged_df.columns:
        merged_df[col] = pd.to_numeric(merged_df[col], errors='coerce')

# ======================
# RQ1: Housing Cost-to-Income by Family Structure
# ======================
merged_df['CostToIncome_Ratio'] = merged_df['median_home_value'] / merged_df['median_income']

merged_df.replace([np.inf, -np.inf], np.nan, inplace=True)

family_types = ['married_couple_families', 'single_father_households', 'single_mother_households']
family_affordability = merged_df.groupby(family_types)['CostToIncome_Ratio'].median().reset_index()

plt.figure(figsize=(10, 6))
sns.barplot(data=family_affordability.melt(id_vars='CostToIncome_Ratio'),
            x='variable', y='value', hue='variable')
plt.title('Housing Cost-to-Income Ratio by Family Structure')
plt.ylabel('Ratio (Home Value / Income)')
plt.xlabel('Family Type')
plt.show()

# ======================
# RQ2: State-Level Affordability vs. Poverty
# ======================
merged_df['Poverty_Tertile'] = pd.qcut(merged_df['poverty_rate_pct'], 3, labels=['Low', 'Medium', 'High'])

affordability_metric = merged_df.groupby('state').apply(
    lambda x: (x['median_home_value'] < 3 * x['median_income']).mean() * 100
).sort_values()

nv_sd_comparison = affordability_metric.loc[['32', '46']]  # NV and SD FIPS codes
print("Affordability Comparison (NV vs SD):")
print(nv_sd_comparison)

# ======================
# RQ3: Bedroom Shortage Analysis
# ======================
if 'NumberOfBedrooms' in merged_df.columns:
    merged_df['NumberOfBedrooms'] = pd.to_numeric(merged_df['NumberOfBedrooms'], errors='coerce')
    bedroom_gap = merged_df.groupby('FullFIPS').apply(
        lambda x: (x['NumberOfBedrooms'] >= 3).sum() / len(x) -
                  (x['avg_household_size_owners'] >= 3).mean()
    ).sort_values()

    plt.figure(figsize=(10, 6))
    bedroom_gap.plot(kind='bar')
    plt.title('Gap Between 3+ Bedroom Units and Large Households')
    plt.ylabel('Proportion Gap')
    plt.show()

# ======================
# RQ4: Climate Risk Analysis
# ======================
if all(col in merged_df.columns for col in ['CentroidLatitude', 'CentroidLongitude', 'FloodZoneRiskLevel']):
    fig = px.scatter_mapbox(merged_df,
                            lat='CentroidLatitude',
                            lon='CentroidLongitude',
                            color='FloodZoneRiskLevel',
                            size='rent_pct_income',
                            hover_name='NAME',
                            mapbox_style="open-street-map",
                            zoom=4)
    fig.update_layout(title='Flood Risk vs Rent Burden')
    fig.show()

# ======================
# RQ5: Insurance Claims Analysis
# ======================
# Convert additional numeric columns
if 'NumberOfClaims' in merged_df.columns:
    merged_df['NumberOfClaims'] = pd.to_numeric(merged_df['NumberOfClaims'], errors='coerce')
    merged_df['YearBuilt'] = pd.to_numeric(merged_df['YearBuilt'], errors='coerce')
    merged_df['AdjSquareFeet'] = pd.to_numeric(merged_df['AdjSquareFeet'], errors='coerce')

    # LASSO Regression
    X = pd.get_dummies(merged_df[['ConstructionType', 'YearBuilt', 'AdjSquareFeet']].dropna())
    y = merged_df['NumberOfClaims'].dropna()

    if len(X) > 0 and len(y) > 0:
        lasso = LassoCV(cv=5).fit(X, y)
        print("Top predictors:", X.columns[lasso.coef_ != 0])

        # SHAP Analysis
        explainer = shap.Explainer(lasso, X)
        shap_values = explainer(X)
        shap.summary_plot(shap_values, X)

# ======================
# Methodology Implementation
# ======================
# Task 3.1: Multilevel Regression
model = smf.mixedlm(
    "CostToIncome_Ratio ~ family_households + poverty_rate_pct",
    data=merged_df.dropna(subset=['CostToIncome_Ratio', 'family_households', 'poverty_rate_pct']),
    groups=merged_df["state"]
).fit()
print(model.summary())

# ======================
# Visualization & Reporting
# ======================
# Choropleth map of affordability
fig = px.choropleth(merged_df,
                    locations='state',
                    color='CostToIncome_Ratio',
                    scope='usa',
                    title='Housing Affordability by State')
fig.show()

# Interactive dashboard
fig = px.scatter(merged_df.dropna(subset=['median_income', 'median_home_value', 'poverty_rate_pct']),
                 x='median_income',
                 y='median_home_value',
                 color='poverty_rate_pct',
                 hover_name='NAME',
                 size='total_population',
                 title='Income vs Home Value with Poverty Overlay')
fig.show()

